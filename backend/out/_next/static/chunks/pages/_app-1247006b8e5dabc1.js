(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[888],{1118:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/_app",function(){return n(8484)}])},8484:function(e,t,n){"use strict";n.r(t);var o=n(5893),r=(n(6774),n(2804));function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{},o=Object.keys(n);"function"===typeof Object.getOwnPropertySymbols&&(o=o.concat(Object.getOwnPropertySymbols(n).filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable})))),o.forEach((function(t){a(e,t,n[t])}))}return e}t.default=function(e){var t=e.Component,n=e.pageProps;return(0,o.jsx)(r.Wh,{children:(0,o.jsx)(t,s({},n))})}},6774:function(){},2804:function(e,t,n){"use strict";n.d(t,{FV:function(){return Rs},Wh:function(){return bs},cn:function(){return ws},sJ:function(){return Ts}});var o=n(7294),r=n(3935);var a=function(e){const t=new Error(e);if(void 0===t.stack)try{throw t}catch(n){}return t};var s=function(e){return!!e&&"function"===typeof e.then};var i=function(e,t){if(null!=e)return e;throw a(null!==t&&void 0!==t?t:"Got unexpected null or undefined")};function u(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}class c{getValue(){throw a("BaseLoadable")}toPromise(){throw a("BaseLoadable")}valueMaybe(){throw a("BaseLoadable")}valueOrThrow(){throw a(`Loadable expected value, but in "${this.state}" state`)}promiseMaybe(){throw a("BaseLoadable")}promiseOrThrow(){throw a(`Loadable expected promise, but in "${this.state}" state`)}errorMaybe(){throw a("BaseLoadable")}errorOrThrow(){throw a(`Loadable expected error, but in "${this.state}" state`)}is(e){return e.state===this.state&&e.contents===this.contents}map(e){throw a("BaseLoadable")}}class l extends c{constructor(e){super(),u(this,"state","hasValue"),u(this,"contents",void 0),this.contents=e}getValue(){return this.contents}toPromise(){return Promise.resolve(this.contents)}valueMaybe(){return this.contents}valueOrThrow(){return this.contents}promiseMaybe(){}errorMaybe(){}map(e){try{const t=e(this.contents);return s(t)?v(t):m(t)?t:h(t)}catch(t){return s(t)?v(t.next((()=>this.map(e)))):p(t)}}}class d extends c{constructor(e){super(),u(this,"state","hasError"),u(this,"contents",void 0),this.contents=e}getValue(){throw this.contents}toPromise(){return Promise.reject(this.contents)}valueMaybe(){}promiseMaybe(){}errorMaybe(){return this.contents}errorOrThrow(){return this.contents}map(e){return this}}class f extends c{constructor(e){super(),u(this,"state","loading"),u(this,"contents",void 0),this.contents=e}getValue(){throw this.contents}toPromise(){return this.contents}valueMaybe(){}promiseMaybe(){return this.contents}promiseOrThrow(){return this.contents}errorMaybe(){}map(e){return v(this.contents.then((t=>{const n=e(t);if(m(n)){const e=n;switch(e.state){case"hasValue":case"loading":return e.contents;case"hasError":throw e.contents}}return n})).catch((t=>{if(s(t))return t.then((()=>this.map(e).contents));throw t})))}}function h(e){return Object.freeze(new l(e))}function p(e){return Object.freeze(new d(e))}function v(e){return Object.freeze(new f(e))}function y(e){const t=function(e){return e.every((e=>"hasValue"===e.state))?h(e.map((e=>e.contents))):e.some((e=>"hasError"===e.state))?p(i(e.find((e=>"hasError"===e.state)),"Invalid loadable passed to loadableAll").contents):v(Promise.all(e.map((e=>e.contents))))}(Array.isArray(e)?e:Object.getOwnPropertyNames(e).map((t=>e[t])));return Array.isArray(e)?t:t.map((t=>Object.getOwnPropertyNames(e).reduce(((e,n,o)=>({...e,[n]:t[o]})),{})))}function m(e){return e instanceof c}const _={of:e=>s(e)?v(e):h(e),error:e=>p(e),all:y,isLoadable:m};var g={loadableWithValue:h,loadableWithError:p,loadableWithPromise:v,loadableLoading:function(){return Object.freeze(new f(new Promise((()=>{}))))},loadableAll:y,isLoadable:m,RecoilLoadable:_},S=g.loadableWithValue,b=g.loadableWithError,w=g.loadableWithPromise,T=g.loadableLoading,R=g.loadableAll,A=g.isLoadable,E=g.RecoilLoadable,N=Object.freeze({__proto__:null,loadableWithValue:S,loadableWithError:b,loadableWithPromise:w,loadableLoading:T,loadableAll:R,isLoadable:A,RecoilLoadable:E});var k,V=function(e,...t){0};const L=null!==(k=o.useMutableSource)&&void 0!==k?k:o.unstable_useMutableSource;var M={mutableSourceExists:function(){return L&&!("undefined"!==typeof window&&window.$disableRecoilValueMutableSource_TEMP_HACK_DO_NOT_USE)},useMutableSource:L};const{mutableSourceExists:C}=M,U=(new Map).set("recoil_hamt_2020",!0).set("recoil_memory_managament_2020",!0).set("recoil_suppress_rerender_in_callback",!0);function B(e){var t;return!("recoil_early_rendering_2021"===e&&!C())&&(null!==(t=U.get(e))&&void 0!==t&&t)}B.setPass=e=>{U.set(e,!0)},B.setFail=e=>{U.set(e,!1)};var D=B;var x=function(e,t){return function*(){let n=0;for(const o of e)yield t(o,n++)}()};var I=function(e,t,{error:n}={}){return null};class O{constructor(e){u(this,"key",void 0),this.key=e}}class P extends O{}class z extends O{}var F={AbstractRecoilValue:O,RecoilState:P,RecoilValueReadOnly:z,isRecoilValue:function(e){return e instanceof P||e instanceof z}},j=F.AbstractRecoilValue,W=F.RecoilState,$=F.RecoilValueReadOnly,q=F.isRecoilValue,G=Object.freeze({__proto__:null,AbstractRecoilValue:j,RecoilState:W,RecoilValueReadOnly:$,isRecoilValue:q});class H{}const K=new H;class Z extends Error{constructor(e){super(`Tried to set the value of Recoil selector ${e} using an updater function, but it is an async selector in a pending or error state; this is not supported.`)}}const J=new Map,X=new Map;class Q extends Error{}const Y=new Map;function ee(e){return Y.get(e)}var te={nodes:J,recoilValues:X,registerNode:function(e){if(J.has(e.key)){const t=`Duplicate atom key "${e.key}". This is a FATAL ERROR in\n      production. But it is safe to ignore this warning if it occurred because of\n      hot module replacement.`;console.warn(t)}J.set(e.key,e);const t=null==e.set?new G.RecoilValueReadOnly(e.key):new G.RecoilState(e.key);return X.set(e.key,t),t},getNode:function(e){const t=J.get(e);if(null==t)throw new Q(`Missing definition for RecoilValue: "${e}""`);return t},getNodeMaybe:function(e){return J.get(e)},deleteNodeConfigIfPossible:function(e){var t;if(!D("recoil_memory_managament_2020"))return;const n=J.get(e);var o;(null===n||void 0===n||null===(t=n.shouldDeleteConfigOnRelease)||void 0===t?void 0:t.call(n))&&(J.delete(e),null===(o=ee(e))||void 0===o||o(),Y.delete(e))},setConfigDeletionHandler:function(e,t){D("recoil_memory_managament_2020")&&(void 0===t?Y.delete(e):Y.set(e,t))},getConfigDeletionHandler:ee,recoilValuesForKeys:function(e){return x(e,(e=>i(X.get(e))))},NodeMissingError:Q,DefaultValue:H,DEFAULT_VALUE:K,RecoilValueNotReady:Z};var ne={enqueueExecution:function(e,t){t()}};var oe,re,ae=(oe=function(e){var t="function"===typeof Symbol&&"symbol"===typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"===typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},n={},o=Math.pow(2,5),r=o-1,a=o/2,s=o/4,i={},u=function(e){return function(){return e}},c=n.hash=function(e){var n="undefined"===typeof e?"undefined":t(e);if("number"===n)return e;"string"!==n&&(e+="");for(var o=0,r=0,a=e.length;r<a;++r)o=(o<<5)-o+e.charCodeAt(r)|0;return o},l=function(e,t){return t>>>e&r},d=function(e){return 1<<e},f=function(e,t){return n=e&t-1,n=(n=(858993459&(n-=n>>1&1431655765))+(n>>2&858993459))+(n>>4)&252645135,127&(n+=n>>8)+(n>>16);var n},h=function(e,t,n,o){var r=o;if(!e){var a=o.length;r=new Array(a);for(var s=0;s<a;++s)r[s]=o[s]}return r[t]=n,r},p=function(e,t,n){var o=n.length-1,r=0,a=0,s=n;if(e)r=a=t;else for(s=new Array(o);r<t;)s[a++]=n[r++];for(++r;r<=o;)s[a++]=n[r++];return e&&(s.length=o),s},v={__hamt_isEmpty:!0},y=function(e){return e===v||e&&e.__hamt_isEmpty},m=function(e,t,n,o){return{type:1,edit:e,hash:t,key:n,value:o,_modify:T}},_=function(e,t,n){return{type:2,edit:e,hash:t,children:n,_modify:R}},g=function(e,t,n){return{type:3,edit:e,mask:t,children:n,_modify:A}},S=function(e,t,n){return{type:4,edit:e,size:t,children:n,_modify:E}},b=function e(t,n,o,r,a,s){if(o===a)return _(t,o,[s,r]);var i=l(n,o),u=l(n,a);return g(t,d(i)|d(u),i===u?[e(t,n+5,o,r,a,s)]:i<u?[r,s]:[s,r])},w=function(e,t){return e===t.edit},T=function(e,t,n,o,r,a,s){if(t(a,this.key)){var u=o(this.value);return u===this.value?this:u===i?(--s.value,v):w(e,this)?(this.value=u,this):m(e,r,a,u)}var c=o();return c===i?this:(++s.value,b(e,n,this.hash,this,r,m(e,r,a,c)))},R=function(e,t,n,o,r,a,s){if(r===this.hash){var u=function(e,t,n,o,r,a,s,u){for(var c=r.length,l=0;l<c;++l){var d=r[l];if(n(s,d.key)){var f=d.value,v=a(f);return v===f?r:v===i?(--u.value,p(e,l,r)):h(e,l,m(t,o,s,v),r)}}var y=a();return y===i?r:(++u.value,h(e,c,m(t,o,s,y),r))}(w(e,this),e,t,this.hash,this.children,o,a,s);return u===this.children?this:u.length>1?_(e,this.hash,u):u[0]}var c=o();return c===i?this:(++s.value,b(e,n,this.hash,this,r,m(e,r,a,c)))},A=function(e,t,n,o,r,s,i){var u=this.mask,c=this.children,m=l(n,r),_=d(m),b=f(u,_),T=u&_,R=T?c[b]:v,A=R._modify(e,t,n+5,o,r,s,i);if(R===A)return this;var E,N=w(e,this),k=u,V=void 0;if(T&&y(A)){if(!(k&=~_))return v;if(c.length<=2&&((E=c[1^b])===v||1===E.type||2===E.type))return c[1^b];V=p(N,b,c)}else if(T||y(A))V=h(N,b,A,c);else{if(c.length>=a)return function(e,t,n,o,r){for(var a=[],s=o,i=0,u=0;s;++u)1&s&&(a[u]=r[i++]),s>>>=1;return a[t]=n,S(e,i+1,a)}(e,m,A,u,c);k|=_,V=function(e,t,n,o){var r=o.length;if(e){for(var a=r;a>=t;)o[a--]=o[a];return o[t]=n,o}for(var s=0,i=0,u=new Array(r+1);s<t;)u[i++]=o[s++];for(u[t]=n;s<r;)u[++i]=o[s++];return u}(N,b,A,c)}return N?(this.mask=k,this.children=V,this):g(e,k,V)},E=function(e,t,n,o,r,a,i){var u=this.size,c=this.children,d=l(n,r),f=c[d],p=(f||v)._modify(e,t,n+5,o,r,a,i);if(f===p)return this;var m=w(e,this),_=void 0;if(y(f)&&!y(p))++u,_=h(m,d,p,c);else if(!y(f)&&y(p)){if(--u<=s)return function(e,t,n,o){for(var r=new Array(t-1),a=0,s=0,i=0,u=o.length;i<u;++i)if(i!==n){var c=o[i];c&&!y(c)&&(r[a++]=c,s|=1<<i)}return g(e,s,r)}(e,u,d,c);_=h(m,d,v,c)}else _=h(m,d,p,c);return m?(this.size=u,this.children=_,this):S(e,u,_)};function N(e,t,n,o,r){this._editable=e,this._edit=t,this._config=n,this._root=o,this._size=r}v._modify=function(e,t,n,o,r,a,s){var u=o();return u===i?v:(++s.value,m(e,r,a,u))},N.prototype.setTree=function(e,t){return this._editable?(this._root=e,this._size=t,this):e===this._root?this:new N(this._editable,this._edit,this._config,e,t)};var k=n.tryGetHash=function(e,t,n,o){for(var r=o._root,a=0,s=o._config.keyEq;;)switch(r.type){case 1:return s(n,r.key)?r.value:e;case 2:if(t===r.hash)for(var i=r.children,u=0,c=i.length;u<c;++u){var h=i[u];if(s(n,h.key))return h.value}return e;case 3:var p=l(a,t),v=d(p);if(r.mask&v){r=r.children[f(r.mask,v)],a+=5;break}return e;case 4:if(r=r.children[l(a,t)]){a+=5;break}return e;default:return e}};N.prototype.tryGetHash=function(e,t,n){return k(e,t,n,this)};var V=n.tryGet=function(e,t,n){return k(e,n._config.hash(t),t,n)};N.prototype.tryGet=function(e,t){return V(e,t,this)};var L=n.getHash=function(e,t,n){return k(void 0,e,t,n)};N.prototype.getHash=function(e,t){return L(e,t,this)},n.get=function(e,t){return k(void 0,t._config.hash(e),e,t)},N.prototype.get=function(e,t){return V(t,e,this)};var M=n.has=function(e,t,n){return k(i,e,t,n)!==i};N.prototype.hasHash=function(e,t){return M(e,t,this)};var C=n.has=function(e,t){return M(t._config.hash(e),e,t)};N.prototype.has=function(e){return C(e,this)};var U=function(e,t){return e===t};n.make=function(e){return new N(0,0,{keyEq:e&&e.keyEq||U,hash:e&&e.hash||c},v,0)},n.empty=n.make();var B=n.isEmpty=function(e){return e&&!!y(e._root)};N.prototype.isEmpty=function(){return B(this)};var D=n.modifyHash=function(e,t,n,o){var r={value:o._size},a=o._root._modify(o._editable?o._edit:NaN,o._config.keyEq,0,e,t,n,r);return o.setTree(a,r.value)};N.prototype.modifyHash=function(e,t,n){return D(n,e,t,this)};var x=n.modify=function(e,t,n){return D(e,n._config.hash(t),t,n)};N.prototype.modify=function(e,t){return x(t,e,this)};var I=n.setHash=function(e,t,n,o){return D(u(n),e,t,o)};N.prototype.setHash=function(e,t,n){return I(e,t,n,this)};var O=n.set=function(e,t,n){return I(n._config.hash(e),e,t,n)};N.prototype.set=function(e,t){return O(e,t,this)};var P=u(i),z=n.removeHash=function(e,t,n){return D(P,e,t,n)};N.prototype.removeHash=N.prototype.deleteHash=function(e,t){return z(e,t,this)};var F=n.remove=function(e,t){return z(t._config.hash(e),e,t)};N.prototype.remove=N.prototype.delete=function(e){return F(e,this)};var j=n.beginMutation=function(e){return new N(e._editable+1,e._edit+1,e._config,e._root,e._size)};N.prototype.beginMutation=function(){return j(this)};var W=n.endMutation=function(e){return e._editable=e._editable&&e._editable-1,e};N.prototype.endMutation=function(){return W(this)};var $=n.mutate=function(e,t){var n=j(t);return e(n),W(n)};N.prototype.mutate=function(e){return $(e,this)};var q=function(e){return e&&G(e[0],e[1],e[2],e[3],e[4])},G=function(e,t,n,o,r){for(;n<e;){var a=t[n++];if(a&&!y(a))return H(a,o,[e,t,n,o,r])}return q(r)},H=function(e,t,n){switch(e.type){case 1:return{value:t(e),rest:n};case 2:case 4:case 3:var o=e.children;return G(o.length,o,0,t,n);default:return q(n)}},K={done:!0};function Z(e){this.v=e}Z.prototype.next=function(){if(!this.v)return K;var e=this.v;return this.v=q(e.rest),e},Z.prototype[Symbol.iterator]=function(){return this};var J=function(e,t){return new Z(H(e._root,t))},X=function(e){return[e.key,e.value]},Q=n.entries=function(e){return J(e,X)};N.prototype.entries=N.prototype[Symbol.iterator]=function(){return Q(this)};var Y=function(e){return e.key},ee=n.keys=function(e){return J(e,Y)};N.prototype.keys=function(){return ee(this)};var te=function(e){return e.value},ne=n.values=N.prototype.values=function(e){return J(e,te)};N.prototype.values=function(){return ne(this)};var oe=n.fold=function(e,t,n){var o=n._root;if(1===o.type)return e(t,o.value,o.key);for(var r=[o.children],a=void 0;a=r.pop();)for(var s=0,i=a.length;s<i;){var u=a[s++];u&&u.type&&(1===u.type?t=e(t,u.value,u.key):r.push(u.children))}return t};N.prototype.fold=function(e,t){return oe(e,t,this)};var re=n.forEach=function(e,t){return oe((function(n,o,r){return e(o,r,t)}),null,t)};N.prototype.forEach=function(e){return re(e,this)};var ae=n.count=function(e){return e._size};N.prototype.count=function(){return ae(this)},Object.defineProperty(N.prototype,"size",{get:N.prototype.count}),e.exports?e.exports=n:(void 0).hamt=n},oe(re={exports:{}},re.exports),re.exports);class se{constructor(e){u(this,"_map",void 0),this._map=new Map(null===e||void 0===e?void 0:e.entries())}keys(){return this._map.keys()}entries(){return this._map.entries()}get(e){return this._map.get(e)}has(e){return this._map.has(e)}set(e,t){return this._map.set(e,t),this}delete(e){return this._map.delete(e),this}clone(){return ue(this)}toMap(){return new Map(this._map)}}class ie{constructor(e){if(u(this,"_hamt",ae.empty.beginMutation()),e instanceof ie){const t=e._hamt.endMutation();e._hamt=t.beginMutation(),this._hamt=t.beginMutation()}else if(e)for(const[t,n]of e.entries())this._hamt.set(t,n)}keys(){return this._hamt.keys()}entries(){return this._hamt.entries()}get(e){return this._hamt.get(e)}has(e){return this._hamt.has(e)}set(e,t){return this._hamt.set(e,t),this}delete(e){return this._hamt.delete(e),this}clone(){return ue(this)}toMap(){return new Map(this._hamt)}}function ue(e){return D("recoil_hamt_2020")?new ie(e):new se(e)}var ce=ue,le=Object.freeze({__proto__:null,persistentMap:ce});var de=function(e,...t){const n=new Set;e:for(const o of e){for(const e of t)if(e.has(o))continue e;n.add(o)}return n};var fe=function(e,t){const n=new Map;return e.forEach(((e,o)=>{n.set(o,t(e,o))})),n};function he(e,t,n){const{nodeDeps:o,nodeToNodeSubscriptions:r}=t;e.forEach(((e,t)=>{const a=o.get(t);if(a&&n&&a!==n.nodeDeps.get(t))return;o.set(t,new Set(e));if((null==a?e:de(e,a)).forEach((e=>{r.has(e)||r.set(e,new Set);i(r.get(e)).add(t)})),a){de(a,e).forEach((e=>{if(!r.has(e))return;const n=i(r.get(e));n.delete(t),0===n.size&&r.delete(e)}))}}))}var pe={addToDependencyMap:function(e,t,n){n.has(e)||n.set(e,new Set),i(n.get(e)).add(t)},cloneGraph:function(e){return{nodeDeps:fe(e.nodeDeps,(e=>new Set(e))),nodeToNodeSubscriptions:fe(e.nodeToNodeSubscriptions,(e=>new Set(e)))}},graph:function(){return{nodeDeps:new Map,nodeToNodeSubscriptions:new Map}},mergeDepsIntoDependencyMap:function(e,t){e.forEach(((e,n)=>{t.has(n)||t.set(n,new Set);const o=i(t.get(n));e.forEach((e=>o.add(e)))}))},saveDependencyMapToStore:function(e,t,n){var o,r,a,s;const i=t.getState();n!==i.currentTree.version&&n!==(null===(o=i.nextTree)||void 0===o?void 0:o.version)&&n!==(null===(r=i.previousTree)||void 0===r?void 0:r.version)&&I("Tried to save dependencies to a discarded tree");const u=t.getGraph(n);if(he(e,u),n===(null===(a=i.previousTree)||void 0===a?void 0:a.version)){he(e,t.getGraph(i.currentTree.version),u)}if(n===(null===(s=i.previousTree)||void 0===s?void 0:s.version)||n===i.currentTree.version){var c;const n=null===(c=i.nextTree)||void 0===c?void 0:c.version;if(void 0!==n){he(e,t.getGraph(n),u)}}}};const{persistentMap:ve}=le,{graph:ye}=pe;let me=0;const _e=()=>me++;function ge(){const e=_e();return{version:e,stateID:e,transactionMetadata:{},dirtyAtoms:new Set,atomValues:ve(),nonvalidatedAtoms:ve()}}var Se={makeEmptyTreeState:ge,makeEmptyStoreState:function(){const e=ge();return{currentTree:e,nextTree:null,previousTree:null,commitDepth:0,knownAtoms:new Set,knownSelectors:new Set,transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:(new Map).set(e.version,ye()),versionsUsedByComponent:new Map,retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map}},getNextTreeStateVersion:_e};var be=function(...e){const t=new Set;for(const n of e)for(const e of n)t.add(e);return t};var we={setByAddingToSet:function(e,t){const n=new Set(e);return n.add(t),n},setByDeletingFromSet:function(e,t){const n=new Set(e);return n.delete(t),n},mapBySettingInMap:function(e,t,n){const o=new Map(e);return o.set(t,n),o},mapByUpdatingInMap:function(e,t,n){const o=new Map(e);return o.set(t,n(o.get(t))),o},mapByDeletingFromMap:function(e,t){const n=new Map(e);return n.delete(t),n},mapByDeletingMultipleFromMap:function(e,t){const n=new Map(e);return t.forEach((e=>n.delete(e))),n}};var Te=function*(e,t){let n=0;for(const o of e)t(o,n++)&&(yield o)};class Re{}var Ae={RetentionZone:Re,retentionZone:function(){return new Re}};const{setByAddingToSet:Ee}=we,{getNode:Ne,getNodeMaybe:ke,recoilValuesForKeys:Ve}=te,{RetentionZone:Le}=Ae,Me=Object.freeze(new Set);class Ce extends Error{}function Ue(e,t,n,o){const r=e.getState();if(r.nodeCleanupFunctions.has(n))return;const a=Ne(n),s=function(e,t,n){if(!D("recoil_memory_managament_2020"))return()=>{};const{nodesRetainedByZone:o}=e.getState().retention;function r(e){let n=o.get(e);n||o.set(e,n=new Set),n.add(t)}if(n instanceof Le)r(n);else if(Array.isArray(n))for(const a of n)r(a);return()=>{if(!D("recoil_memory_managament_2020"))return;const o=e.getState().retention.nodesRetainedByZone;function r(e){const n=o.get(e);n&&n.delete(t),n&&0===n.size&&o.delete(e)}if(n instanceof Le)r(n);else if(Array.isArray(n))for(const e of n)r(e)}}(e,n,a.retainedBy),i=a.init(e,t,o);r.nodeCleanupFunctions.set(n,(()=>{i(),s()}))}function Be(e,t,n){return Ne(n).peek(e,t)}function De(e,t,n){const o=new Set,r=Array.from(n),a=e.getGraph(t.version);for(let i=r.pop();i;i=r.pop()){var s;o.add(i);const e=null!==(s=a.nodeToNodeSubscriptions.get(i))&&void 0!==s?s:Me;for(const t of e)o.has(t)||r.push(t)}return o}var xe={getNodeLoadable:function(e,t,n){return Ue(e,t,n,"get"),Ne(n).get(e,t)},peekNodeLoadable:Be,setNodeValue:function(e,t,n,o){const r=Ne(n);if(null==r.set)throw new Ce(`Attempt to set read-only RecoilValue: ${n}`);const a=r.set;return Ue(e,t,n,"set"),a(e,t,o)},cleanUpNode:function(e,t){var n;const o=e.getState();null===(n=o.nodeCleanupFunctions.get(t))||void 0===n||n(),o.nodeCleanupFunctions.delete(t)},setUnvalidatedAtomValue_DEPRECATED:function(e,t,n){var o;const r=ke(t);return null===r||void 0===r||null===(o=r.invalidate)||void 0===o||o.call(r,e),{...e,atomValues:e.atomValues.clone().delete(t),nonvalidatedAtoms:e.nonvalidatedAtoms.clone().set(t,n),dirtyAtoms:Ee(e.dirtyAtoms,t)}},peekNodeInfo:function(e,t,n){var o,r,a;const s=e.getState(),i=e.getGraph(t.version),u=s.knownAtoms.has(n)?"atom":s.knownSelectors.has(n)?"selector":void 0,c=Te(De(e,t,new Set([n])),(e=>e!==n));return{loadable:Be(e,t,n),isActive:s.knownAtoms.has(n)||s.knownSelectors.has(n),isSet:"selector"!==u&&t.atomValues.has(n),isModified:t.dirtyAtoms.has(n),type:u,deps:Ve(null!==(o=i.nodeDeps.get(n))&&void 0!==o?o:[]),subscribers:{nodes:Ve(c),components:x(null!==(r=null===(a=s.nodeToComponentSubscriptions.get(n))||void 0===a?void 0:a.values())&&void 0!==r?r:[],(([e])=>({name:e})))}}},getDownstreamNodes:De,initializeNodeIfNewToStore:Ue};const{getDownstreamNodes:Ie,getNodeLoadable:Oe,setNodeValue:Pe}=xe,{getNodeMaybe:ze}=te,{DefaultValue:Fe,RecoilValueNotReady:je}=te,{AbstractRecoilValue:We,RecoilState:$e,RecoilValueReadOnly:qe,isRecoilValue:Ge}=G;function He(e,t,n){if("set"===n.type){const{recoilValue:o,valueOrUpdater:r}=n,a=function(e,t,{key:n},o){if("function"===typeof o){const r=Oe(e,t,n);if("loading"===r.state)throw new je(n);if("hasError"===r.state)throw r.contents;return o(r.contents)}return o}(e,t,o,r),s=Pe(e,t,o.key,a);for(const[e,n]of s.entries())Ke(t,e,n)}else if("setLoadable"===n.type){const{recoilValue:{key:e},loadable:o}=n;Ke(t,e,o)}else if("markModified"===n.type){const{recoilValue:{key:e}}=n;t.dirtyAtoms.add(e)}else if("setUnvalidated"===n.type){var o;const{recoilValue:{key:e},unvalidatedValue:r}=n,a=ze(e);null===a||void 0===a||null===(o=a.invalidate)||void 0===o||o.call(a,t),t.atomValues.delete(e),t.nonvalidatedAtoms.set(e,r),t.dirtyAtoms.add(e)}else I(`Unknown action ${n.type}`)}function Ke(e,t,n){"hasValue"===n.state&&n.contents instanceof Fe?e.atomValues.delete(t):e.atomValues.set(t,n),e.dirtyAtoms.add(t),e.nonvalidatedAtoms.delete(t)}function Ze(e,t){e.replaceState((n=>{const o=Qe(n);for(const r of t)He(e,o,r);return Ye(e,o),o}))}function Je(e,t){if(Xe.length){const n=Xe[Xe.length-1];let o=n.get(e);o||n.set(e,o=[]),o.push(t)}else Ze(e,[t])}const Xe=[];function Qe(e){return{...e,atomValues:e.atomValues.clone(),nonvalidatedAtoms:e.nonvalidatedAtoms.clone(),dirtyAtoms:new Set(e.dirtyAtoms)}}function Ye(e,t){const n=Ie(e,t,t.dirtyAtoms);for(const a of n){var o,r;null===(o=ze(a))||void 0===o||null===(r=o.invalidate)||void 0===r||r.call(o,t)}}function et(e,t,n){Je(e,{type:"set",recoilValue:t,valueOrUpdater:n})}let tt=0;var nt={RecoilValueReadOnly:qe,AbstractRecoilValue:We,RecoilState:$e,getRecoilValueAsLoadable:function(e,{key:t},n=e.getState().currentTree){var o,r;const a=e.getState();n.version!==a.currentTree.version&&n.version!==(null===(o=a.nextTree)||void 0===o?void 0:o.version)&&n.version!==(null===(r=a.previousTree)||void 0===r?void 0:r.version)&&I("Tried to read from a discarded tree");const s=Oe(e,n,t);return"loading"===s.state&&s.contents.catch((()=>{})),s},setRecoilValue:et,setRecoilValueLoadable:function(e,t,n){if(n instanceof Fe)return et(e,t,n);Je(e,{type:"setLoadable",recoilValue:t,loadable:n})},markRecoilValueModified:function(e,t){Je(e,{type:"markModified",recoilValue:t})},setUnvalidatedRecoilValue:function(e,t,n){Je(e,{type:"setUnvalidated",recoilValue:t,unvalidatedValue:n})},subscribeToRecoilValue:function(e,{key:t},n,o=null){const r=tt++,a=e.getState();if(a.nodeToComponentSubscriptions.has(t)||a.nodeToComponentSubscriptions.set(t,new Map),i(a.nodeToComponentSubscriptions.get(t)).set(r,[null!==o&&void 0!==o?o:"<not captured>",n]),D("recoil_early_rendering_2021")){const o=e.getState().nextTree;o&&o.dirtyAtoms.has(t)&&n(o)}return{release:()=>{const n=e.getState(),o=n.nodeToComponentSubscriptions.get(t);void 0!==o&&o.has(r)?(o.delete(r),0===o.size&&n.nodeToComponentSubscriptions.delete(t)):I(`Subscription missing at release time for atom ${t}. This is a bug in Recoil.`)}}},isRecoilValue:Ge,applyAtomValueWrites:function(e,t){const n=e.clone();return t.forEach(((e,t)=>{"hasValue"===e.state&&e.contents instanceof Fe?n.delete(t):n.set(t,e)})),n},batchStart:function(){const e=new Map;return Xe.push(e),()=>{for(const[t,n]of e)Ze(t,n);Xe.pop()!==e&&I("Incorrect order of batch popping")}},writeLoadableToTreeState:Ke,invalidateDownstreams:Ye,copyTreeState:Qe,invalidateDownstreams_FOR_TESTING:Ye};var ot=function(e,t,n){const o=e.entries();let r=o.next();for(;!r.done;){const a=r.value;if(t.call(n,a[1],a[0],e))return!0;r=o.next()}return!1};const{cleanUpNode:rt}=xe,{deleteNodeConfigIfPossible:at,getNode:st}=te,{RetentionZone:it}=Ae,ut=new Set;function ct(e,t){const n=e.getState(),o=n.currentTree;if(n.nextTree)return void I("releaseNodesNowOnCurrentTree should only be called at the end of a batch");const r=new Set;for(const s of t)if(s instanceof it)for(const e of dt(n,s))r.add(e);else r.add(s);const a=function(e,t){const n=e.getState(),o=n.currentTree,r=e.getGraph(o.version),a=new Set,s=new Set;return u(t),a;function u(t){const c=new Set,l=function(e,t,n,o,r){const a=e.getGraph(t.version),s=[],u=new Set;for(;n.size>0;)c(i(n.values().next().value));return s;function c(e){if(o.has(e)||r.has(e))return void n.delete(e);if(u.has(e))return;const t=a.nodeToNodeSubscriptions.get(e);if(t)for(const n of t)c(n);u.add(e),n.delete(e),s.push(e)}}(e,o,t,a,s);for(const e of l){var d;if("recoilRoot"===st(e).retainedBy){s.add(e);continue}if((null!==(d=n.retention.referenceCounts.get(e))&&void 0!==d?d:0)>0){s.add(e);continue}if(ft(e).some((e=>n.retention.referenceCounts.get(e)))){s.add(e);continue}const t=r.nodeToNodeSubscriptions.get(e);t&&ot(t,(e=>s.has(e)))?s.add(e):(a.add(e),c.add(e))}const f=new Set;for(const e of c)for(const t of null!==(h=r.nodeDeps.get(e))&&void 0!==h?h:ut){var h;a.has(t)||f.add(t)}f.size&&u(f)}}(e,r);for(const s of a)lt(e,o,s)}function lt(e,t,n){if(!D("recoil_memory_managament_2020"))return;rt(e,n);const o=e.getState();o.knownAtoms.delete(n),o.knownSelectors.delete(n),o.nodeTransactionSubscriptions.delete(n),o.retention.referenceCounts.delete(n);const r=ft(n);for(const u of r){var a;null===(a=o.retention.nodesRetainedByZone.get(u))||void 0===a||a.delete(n)}t.atomValues.delete(n),t.dirtyAtoms.delete(n),t.nonvalidatedAtoms.delete(n);const s=o.graphsByVersion.get(t.version);if(s){const e=s.nodeDeps.get(n);if(void 0!==e){s.nodeDeps.delete(n);for(const t of e){var i;null===(i=s.nodeToNodeSubscriptions.get(t))||void 0===i||i.delete(n)}}s.nodeToNodeSubscriptions.delete(n)}at(n)}function dt(e,t){var n;return null!==(n=e.retention.nodesRetainedByZone.get(t))&&void 0!==n?n:ut}function ft(e){const t=st(e).retainedBy;return void 0===t||"components"===t||"recoilRoot"===t?[]:t instanceof it?[t]:t}function ht(e,t){if(!D("recoil_memory_managament_2020"))return;e.getState().retention.referenceCounts.delete(t),function(e,t){const n=e.getState();n.nextTree?n.retention.retainablesToCheckForRelease.add(t):ct(e,new Set([t]))}(e,t)}var pt={SUSPENSE_TIMEOUT_MS:12e4,updateRetainCount:function(e,t,n){var o;if(!D("recoil_memory_managament_2020"))return;const r=e.getState().retention.referenceCounts,a=(null!==(o=r.get(t))&&void 0!==o?o:0)+n;0===a?ht(e,t):r.set(t,a)},updateRetainCountToZero:ht,releaseScheduledRetainablesNow:function(e){if(!D("recoil_memory_managament_2020"))return;const t=e.getState();ct(e,t.retention.retainablesToCheckForRelease),t.retention.retainablesToCheckForRelease.clear()},retainedByOptionWithDefault:function(e){return void 0===e?"recoilRoot":e}};var vt=function*(e){for(const t of e)for(const e of t)yield e};var yt={isSSR:"undefined"===typeof window,isReactNative:"undefined"!==typeof navigator&&"ReactNative"===navigator.product};const{unstable_batchedUpdates:mt}=r;var _t={unstable_batchedUpdates:mt};const{unstable_batchedUpdates:gt}=_t;var St={unstable_batchedUpdates:gt};const{batchStart:bt}=nt,{unstable_batchedUpdates:wt}=St;let Tt=wt;var Rt={getBatcher:()=>Tt,setBatcher:e=>{Tt=e},batchUpdates:e=>{Tt((()=>{let t=()=>{};try{t=bt(),e()}finally{t()}}))}};const{isSSR:At}=yt,{batchUpdates:Et}=Rt,{initializeNodeIfNewToStore:Nt,peekNodeInfo:kt}=xe,{graph:Vt}=pe,{DEFAULT_VALUE:Lt,recoilValues:Mt,recoilValuesForKeys:Ct}=te,{AbstractRecoilValue:Ut,getRecoilValueAsLoadable:Bt,setRecoilValue:Dt,setUnvalidatedRecoilValue:xt}=nt,{updateRetainCount:It}=pt,{getNextTreeStateVersion:Ot,makeEmptyStoreState:Pt}=Se;class zt{constructor(e){u(this,"_store",void 0),u(this,"_refCount",0),u(this,"getLoadable",(e=>(this.checkRefCount_INTERNAL(),Bt(this._store,e)))),u(this,"getPromise",(e=>(this.checkRefCount_INTERNAL(),this.getLoadable(e).toPromise()))),u(this,"getNodes_UNSTABLE",(e=>{if(this.checkRefCount_INTERNAL(),!0===(null===e||void 0===e?void 0:e.isModified)){if(!1===(null===e||void 0===e?void 0:e.isInitialized))return[];const t=this._store.getState().currentTree;return Ct(t.dirtyAtoms)}const t=this._store.getState().knownAtoms,n=this._store.getState().knownSelectors;return null==(null===e||void 0===e?void 0:e.isInitialized)?Mt.values():!0===e.isInitialized?Ct(vt([this._store.getState().knownAtoms,this._store.getState().knownSelectors])):Te(Mt.values(),(({key:e})=>!t.has(e)&&!n.has(e)))})),u(this,"getInfo_UNSTABLE",(({key:e})=>(this.checkRefCount_INTERNAL(),kt(this._store,this._store.getState().currentTree,e)))),u(this,"map",(e=>{this.checkRefCount_INTERNAL();const t=new Wt(this,Et);return e(t),jt(t.getStore_INTERNAL())})),u(this,"asyncMap",(async e=>{this.checkRefCount_INTERNAL();const t=new Wt(this,Et);return await e(t),jt(t.getStore_INTERNAL())})),this._store={getState:()=>e,replaceState:t=>{e.currentTree=t(e.currentTree)},getGraph:t=>{const n=e.graphsByVersion;if(n.has(t))return i(n.get(t));const o=Vt();return n.set(t,o),o},subscribeToTransactions:()=>({release:()=>{}}),addTransactionMetadata:()=>{throw a("Cannot subscribe to Snapshots")}};for(const t of this._store.getState().nodeCleanupFunctions.keys())Nt(this._store,e.currentTree,t,"get"),It(this._store,t,1);this.retain(),this.autorelease_INTERNAL()}retain(){if(!D("recoil_memory_managament_2020"))return()=>{};this._refCount++;let e=!1;return()=>{e||(e=!0,this.release_INTERNAL())}}autorelease_INTERNAL(){D("recoil_memory_managament_2020")&&(At||window.setTimeout((()=>this.release_INTERNAL()),0))}release_INTERNAL(){D("recoil_memory_managament_2020")&&(this._refCount--,this._refCount)}checkRefCount_INTERNAL(){D("recoil_memory_managament_2020")&&this._refCount}getStore_INTERNAL(){return this.checkRefCount_INTERNAL(),this._store}getID(){return this.checkRefCount_INTERNAL(),this.getID_INTERNAL()}getID_INTERNAL(){return this.checkRefCount_INTERNAL(),this._store.getState().currentTree.stateID}}function Ft(e,t,n=!1){const o=e.getState(),r=n?Ot():t.version;return{currentTree:n?{version:r,stateID:r,transactionMetadata:{...t.transactionMetadata},dirtyAtoms:new Set(t.dirtyAtoms),atomValues:t.atomValues.clone(),nonvalidatedAtoms:t.nonvalidatedAtoms.clone()}:t,commitDepth:0,nextTree:null,previousTree:null,knownAtoms:new Set(o.knownAtoms),knownSelectors:new Set(o.knownSelectors),transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:(new Map).set(r,e.getGraph(t.version)),versionsUsedByComponent:new Map,retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map}}function jt(e,t="current"){const n=e.getState(),o="current"===t?n.currentTree:i(n.previousTree);return new zt(Ft(e,o))}class Wt extends zt{constructor(e,t){super(Ft(e.getStore_INTERNAL(),e.getStore_INTERNAL().getState().currentTree,!0)),u(this,"_batch",void 0),u(this,"set",((e,t)=>{this.checkRefCount_INTERNAL();const n=this.getStore_INTERNAL();this._batch((()=>{It(n,e.key,1),Dt(this.getStore_INTERNAL(),e,t)}))})),u(this,"reset",(e=>{this.checkRefCount_INTERNAL();const t=this.getStore_INTERNAL();this._batch((()=>{It(t,e.key,1),Dt(this.getStore_INTERNAL(),e,Lt)}))})),u(this,"setUnvalidatedAtomValues_DEPRECATED",(e=>{this.checkRefCount_INTERNAL();const t=this.getStore_INTERNAL();Et((()=>{for(const[n,o]of e.entries())It(t,n,1),xt(t,new Ut(n),o)}))})),this._batch=t}}var $t={Snapshot:zt,MutableSnapshot:Wt,freshSnapshot:function(e){const t=new zt(Pt());return null!=e?t.map(e):t},cloneSnapshot:jt},qt=$t.Snapshot,Gt=$t.MutableSnapshot,Ht=$t.freshSnapshot,Kt=$t.cloneSnapshot,Zt=Object.freeze({__proto__:null,Snapshot:qt,MutableSnapshot:Gt,freshSnapshot:Ht,cloneSnapshot:Kt});const{getNextTreeStateVersion:Jt,makeEmptyStoreState:Xt}=Se,{cleanUpNode:Qt,getDownstreamNodes:Yt,setNodeValue:en,setUnvalidatedAtomValue_DEPRECATED:tn}=xe,{graph:nn}=pe,{cloneGraph:on}=pe,{applyAtomValueWrites:rn}=nt,{releaseScheduledRetainablesNow:an}=pt,{freshSnapshot:sn}=Zt,{useCallback:un,useContext:cn,useEffect:ln,useMemo:dn,useRef:fn,useState:hn}=o;function pn(){throw a("This component must be used inside a <RecoilRoot> component.")}const vn=Object.freeze({getState:pn,replaceState:pn,getGraph:pn,subscribeToTransactions:pn,addTransactionMetadata:pn});let yn=!1;function mn(e){if(yn)throw a("An atom update was triggered within the execution of a state updater function. State updater functions provided to Recoil must be pure functions.");const t=e.getState();if(null===t.nextTree){D("recoil_memory_managament_2020")&&D("recoil_release_on_cascading_update_killswitch_2021")&&t.commitDepth>0&&an(e);const n=t.currentTree.version,o=Jt();t.nextTree={...t.currentTree,version:o,stateID:o,dirtyAtoms:new Set,transactionMetadata:{}},t.graphsByVersion.set(o,on(i(t.graphsByVersion.get(n))))}}const _n=o.createContext({current:vn}),gn=()=>cn(_n),Sn=o.createContext(null);function bn(e,t,n){const o=Yt(e,n,n.dirtyAtoms);for(const r of o){const e=t.nodeToComponentSubscriptions.get(r);if(e)for(const[t,[o,r]]of e)r(n)}}function wn(e){const t=e.getState(),n=t.currentTree,o=n.dirtyAtoms;if(o.size){for(const[n,r]of t.nodeTransactionSubscriptions)if(o.has(n))for(const[t,o]of r)o(e);for(const[n,o]of t.transactionSubscriptions)o(e);D("recoil_early_rendering_2021")&&!t.suspendedComponentResolvers.size||(bn(e,t,n),t.suspendedComponentResolvers.forEach((e=>e())),t.suspendedComponentResolvers.clear())}t.queuedComponentCallbacks_DEPRECATED.forEach((e=>e(n))),t.queuedComponentCallbacks_DEPRECATED.splice(0,t.queuedComponentCallbacks_DEPRECATED.length)}function Tn({setNotifyBatcherOfChange:e}){const t=gn(),[n,o]=hn([]);return e((()=>o({}))),ln((()=>{ne.enqueueExecution("Batcher",(()=>{!function(e){const t=e.current.getState();t.commitDepth++;try{const{nextTree:n}=t;if(null===n)return;t.previousTree=t.currentTree,t.currentTree=n,t.nextTree=null,wn(e.current),null!=t.previousTree?t.graphsByVersion.delete(t.previousTree.version):I("Ended batch with no previous state, which is unexpected","recoil"),t.previousTree=null,D("recoil_memory_managament_2020")&&an(e.current)}finally{t.commitDepth--}}(t)}))})),ln((()=>()=>{e((()=>{}))}),[e]),null}let Rn=0;function An({initializeState_DEPRECATED:e,initializeState:t,store_INTERNAL:n,children:r}){var a;let s;const u=fn(null),c=un((e=>{u.current=e}),[u]),l=null!==(a=o.createMutableSource)&&void 0!==a?a:o.unstable_createMutableSource,d=null!==n&&void 0!==n?n:{getState:()=>s.current,replaceState:e=>{const t=f.current.getState();mn(f.current);const n=i(t.nextTree);let o;try{yn=!0,o=e(n)}finally{yn=!1}o!==n&&(t.nextTree=o,D("recoil_early_rendering_2021")&&bn(d,t,o),i(u.current)())},getGraph:e=>{const t=s.current.graphsByVersion;if(t.has(e))return i(t.get(e));const n=nn();return t.set(e,n),n},subscribeToTransactions:(e,t)=>{if(null==t){const{transactionSubscriptions:t}=f.current.getState(),n=Rn++;return t.set(n,e),{release:()=>{t.delete(n)}}}{const{nodeTransactionSubscriptions:n}=f.current.getState();n.has(t)||n.set(t,new Map);const o=Rn++;return i(n.get(t)).set(o,e),{release:()=>{const e=n.get(t);e&&(e.delete(o),0===e.size&&n.delete(t))}}}},addTransactionMetadata:e=>{mn(f.current);for(const t of Object.keys(e))i(f.current.getState().nextTree).transactionMetadata[t]=e[t]}},f=fn(d);s=fn(null!=e?function(e,t){const n=Xt();return t({set:(t,o)=>{const r=n.currentTree,a=en(e,r,t.key,o),s=new Set(a.keys()),i=r.nonvalidatedAtoms.clone();for(const e of s)i.delete(e);n.currentTree={...r,dirtyAtoms:be(r.dirtyAtoms,s),atomValues:rn(r.atomValues,a),nonvalidatedAtoms:i}},setUnvalidatedAtomValues:e=>{e.forEach(((e,t)=>{n.currentTree=tn(n.currentTree,t,e)}))}}),n}(d,e):null!=t?function(e){return sn().map(e).getStore_INTERNAL().getState()}(t):Xt());const h=dn((()=>l?l(s,(()=>s.current.currentTree.version)):null),[l,s]);return ln((()=>()=>{for(const e of f.current.getState().knownAtoms)Qt(f.current,e)}),[]),o.createElement(_n.Provider,{value:f},o.createElement(Sn.Provider,{value:h},o.createElement(Tn,{setNotifyBatcherOfChange:c}),r))}var En={useStoreRef:gn,useRecoilMutableSource:function(){const e=cn(Sn);return null==e&&V("Attempted to use a Recoil hook outside of a <RecoilRoot>. <RecoilRoot> must be an ancestor of any component that uses Recoil hooks."),e},RecoilRoot:function(e){const{override:t,...n}=e,r=gn();return!1===t&&r.current!==vn?e.children:o.createElement(An,n)},notifyComponents_FOR_TESTING:bn,sendEndOfBatchNotifications_FOR_TESTING:wn};const{useRef:Nn}=o;var kn=function(){return Nn(),"<component name not available>"};var Vn=function(e,t){if(e===t)return!0;if(e.length!==t.length)return!1;for(let n=0,o=e.length;n<o;n++)if(e[n]!==t[n])return!1;return!0};const{useEffect:Ln,useRef:Mn}=o;var Cn=function(e){const t=Mn();return Ln((()=>{t.current=e})),t.current};const{useStoreRef:Un}=En,{SUSPENSE_TIMEOUT_MS:Bn}=pt,{updateRetainCount:Dn}=pt,{RetentionZone:xn}=Ae,{isSSR:In}=yt,{useEffect:On,useRef:Pn}=o;var zn=function(e){if(D("recoil_memory_managament_2020"))return function(e){const t=(Array.isArray(e)?e:[e]).map((e=>e instanceof xn?e:e.key)),n=Un();On((()=>{if(!D("recoil_memory_managament_2020"))return;const e=n.current;if(o.current&&!In)window.clearTimeout(o.current),o.current=null;else for(const n of t)Dn(e,n,1);return()=>{for(const n of t)Dn(e,n,-1)}}),[n,...t]);const o=Pn(),r=Cn(t);if(!In&&(void 0===r||!Vn(r,t))){const e=n.current;for(const n of t)Dn(e,n,1);if(r)for(const t of r)Dn(e,t,-1);o.current&&window.clearTimeout(o.current),o.current=window.setTimeout((()=>{o.current=null;for(const n of t)Dn(e,n,-1)}),Bn)}}(e)};const{batchUpdates:Fn}=Rt,{DEFAULT_VALUE:jn}=te,{useRecoilMutableSource:Wn,useStoreRef:$n}=En,{isRecoilValue:qn}=G,{AbstractRecoilValue:Gn,getRecoilValueAsLoadable:Hn,setRecoilValue:Kn,setUnvalidatedRecoilValue:Zn,subscribeToRecoilValue:Jn}=nt,{setByAddingToSet:Xn}=we,{mutableSourceExists:Qn,useMutableSource:Yn}=M,{useCallback:eo,useEffect:to,useMemo:no,useRef:oo,useState:ro}=o;function ao(e,t,n){if("hasValue"===e.state)return e.contents;if("loading"===e.state){throw new Promise((e=>{n.current.getState().suspendedComponentResolvers.add(e)}))}throw"hasError"===e.state?e.contents:a(`Invalid value of loadable atom "${t.key}"`)}function so(e){return D("recoil_memory_managament_2020")&&zn(e),Qn()?function(e){const t=$n(),n=eo((()=>{var n;const o=t.current,r=o.getState(),a=D("recoil_early_rendering_2021")&&null!==(n=r.nextTree)&&void 0!==n?n:r.currentTree;return Hn(o,e,a)}),[t,e]),o=eo((()=>n()),[n]),r=kn(),a=eo(((o,a)=>{const s=t.current;return Jn(s,e,(()=>{if(!D("recoil_suppress_rerender_in_callback"))return a();const e=n();u.current.is(e)||a(),u.current=e}),r).release}),[t,e,r,n]),s=Wn(),i=Yn(s,o,a),u=oo(i);return to((()=>{u.current=i})),i}(e):function(e){const t=$n(),[n,o]=ro([]),r=kn();to((()=>{const n=t.current,a=n.getState(),i=Jn(n,e,(t=>{var r;if(!D("recoil_suppress_rerender_in_callback"))return o([]);const a=Hn(n,e,n.getState().currentTree);(null===(r=s.current)||void 0===r?void 0:r.is(a))||o(a),s.current=a}),r);if(a.nextTree)n.getState().queuedComponentCallbacks_DEPRECATED.push((()=>{s.current=null,o([])}));else{var u;if(!D("recoil_suppress_rerender_in_callback"))return o([]);const t=Hn(n,e,n.getState().currentTree);(null===(u=s.current)||void 0===u?void 0:u.is(t))||o(t),s.current=t}return i.release}),[r,e,t]);const a=Hn(t.current,e),s=oo(a);return to((()=>{s.current=a})),a}(e)}function io(e){const t=$n();return ao(so(e),e,t)}function uo(e){const t=$n();return eo((n=>{Kn(t.current,e,n)}),[t,e])}var co={recoilComponentGetRecoilValueCount_FOR_TESTING:{current:0},useRecoilInterface:function(){const e=$n(),[,t]=ro([]),n=oo(new Set);n.current=new Set;const o=oo(new Set),r=oo(new Map),a=eo((e=>{const t=r.current.get(e);t&&(t.release(),r.current.delete(e))}),[r]),s=kn();return to((()=>{const i=e.current;function u(e,n){r.current.has(n)&&t([])}de(n.current,o.current).forEach((e=>{if(r.current.has(e))return void V(`Double subscription to RecoilValue "${e}"`);const t=Jn(i,new Gn(e),(t=>{u(0,e)}),s);r.current.set(e,t);i.getState().nextTree?i.getState().queuedComponentCallbacks_DEPRECATED.push((()=>{u(i.getState(),e)})):u(i.getState(),e)})),de(o.current,n.current).forEach((e=>{a(e)})),o.current=n.current})),to((()=>{const e=r.current;return()=>e.forEach(((e,t)=>a(t)))}),[a]),no((()=>{function t(t){return n=>{Kn(e.current,t,n)}}function o(t){var o;n.current.has(t.key)||(n.current=Xn(n.current,t.key));const r=e.current.getState();return Hn(e.current,t,D("recoil_early_rendering_2021")&&null!==(o=r.nextTree)&&void 0!==o?o:r.currentTree)}function r(t){return ao(o(t),t,e)}return{getRecoilValue:r,getRecoilValueLoadable:o,getRecoilState:function(e){return[r(e),t(e)]},getRecoilStateLoadable:function(e){return[o(e),t(e)]},getSetRecoilState:t,getResetRecoilState:function(t){return()=>Kn(e.current,t,jn)}}}),[n,e])},useRecoilState:function(e){return[io(e),uo(e)]},useRecoilStateLoadable:function(e){return[so(e),uo(e)]},useRecoilValue:io,useRecoilValueLoadable:so,useResetRecoilState:function(e){const t=$n();return eo((()=>{Kn(t.current,e,jn)}),[t,e])},useSetRecoilState:uo,useSetUnvalidatedAtomValues:function(){const e=$n();return(t,n={})=>{Fn((()=>{e.current.addTransactionMetadata(n),t.forEach(((t,n)=>Zn(e.current,new Gn(n),t)))}))}}};var lo=function(e,t){const n=new Map;for(const[o,r]of e)t(r,o)&&n.set(o,r);return n};var fo=function(e,t){const n=new Set;for(const o of e)t(o)&&n.add(o);return n};var ho=function(...e){const t=new Map;for(let n=0;n<e.length;n++){const o=e[n].keys();let r;for(;!(r=o.next()).done;)t.set(r.value,e[n].get(r.value))}return t};const{batchUpdates:po}=Rt,{DEFAULT_VALUE:vo,getNode:yo,nodes:mo}=te,{useStoreRef:_o}=En,{AbstractRecoilValue:go,setRecoilValueLoadable:So}=nt,{SUSPENSE_TIMEOUT_MS:bo}=pt,{Snapshot:wo,cloneSnapshot:To}=Zt,{isSSR:Ro}=yt,{useCallback:Ao,useEffect:Eo,useRef:No,useState:ko}=o;function Vo(e){const t=_o();Eo((()=>t.current.subscribeToTransactions(e).release),[e,t])}function Lo(e){const t=e.atomValues.toMap(),n=fe(lo(t,((e,t)=>{const n=yo(t).persistence_UNSTABLE;return null!=n&&"none"!==n.type&&"hasValue"===e.state})),(e=>e.contents));return ho(e.nonvalidatedAtoms.toMap(),n)}var Mo={useRecoilSnapshot:function(){const e=_o(),[t,n]=ko((()=>To(e.current))),o=Cn(t),r=No();return Eo((()=>(r.current&&!Ro&&window.clearTimeout(r.current),t.retain())),[t]),Vo(Ao((e=>n(To(e))),[])),o===t||Ro||(r.current&&(null===o||void 0===o||o.release_INTERNAL(),window.clearTimeout(r.current)),t.retain(),r.current=window.setTimeout((()=>{t.release_INTERNAL(),r.current=null}),bo)),t},useGotoRecoilSnapshot:function(){const e=_o();return Ao((t=>{var n;const o=e.current.getState(),r=null!==(n=o.nextTree)&&void 0!==n?n:o.currentTree,a=t.getStore_INTERNAL().getState().currentTree;po((()=>{const n=new Set;for(const e of[r.atomValues.keys(),a.atomValues.keys()])for(const t of e){var o,s;(null===(o=r.atomValues.get(t))||void 0===o?void 0:o.contents)!==(null===(s=a.atomValues.get(t))||void 0===s?void 0:s.contents)&&yo(t).shouldRestoreFromSnapshots&&n.add(t)}n.forEach((t=>{So(e.current,new go(t),a.atomValues.has(t)?i(a.atomValues.get(t)):vo)})),e.current.replaceState((e=>({...e,stateID:t.getID_INTERNAL()})))}))}),[e])},useRecoilTransactionObserver:function(e){Vo(Ao((t=>{const n=To(t,"current"),o=To(t,"previous");e({snapshot:n,previousSnapshot:o})}),[e]))},useTransactionObservation_DEPRECATED:function(e){Vo(Ao((t=>{let n=t.getState().previousTree;const o=t.getState().currentTree;n||(I("Transaction subscribers notified without a previous tree being present -- this is a bug in Recoil"),n=t.getState().currentTree);const r=Lo(o),a=Lo(n),s=fe(mo,(e=>{var t,n,o,r;return{persistence_UNSTABLE:{type:null!==(t=null===(n=e.persistence_UNSTABLE)||void 0===n?void 0:n.type)&&void 0!==t?t:"none",backButton:null!==(o=null===(r=e.persistence_UNSTABLE)||void 0===r?void 0:r.backButton)&&void 0!==o&&o}}})),i=fo(o.dirtyAtoms,(e=>r.has(e)||a.has(e)));e({atomValues:r,previousAtomValues:a,atomInfo:s,modifiedAtoms:i,transactionMetadata:{...o.transactionMetadata}})}),[e]))},useTransactionSubscription_DEPRECATED:Vo};const{peekNodeInfo:Co}=xe,{useStoreRef:Uo}=En;var Bo=function(){const e=Uo();return({key:t})=>Co(e.current,e.current.getState().currentTree,t)};const{RecoilRoot:Do,useStoreRef:xo}=En,{useMemo:Io}=o;var Oo=function(){const e=xo().current;return Io((()=>function({children:t}){return o.createElement(Do,{store_INTERNAL:e},t)}),[e])};const{loadableWithValue:Po}=N,{DEFAULT_VALUE:zo,getNode:Fo}=te,{copyTreeState:jo,getRecoilValueAsLoadable:Wo,invalidateDownstreams:$o,writeLoadableToTreeState:qo}=nt;function Go(e){return"atom"===Fo(e.key).nodeType}class Ho{constructor(e,t){u(this,"_store",void 0),u(this,"_treeState",void 0),u(this,"_changes",void 0),u(this,"get",(e=>{if(this._changes.has(e.key))return this._changes.get(e.key);if(!Go(e))throw a("Reading selectors within atomicUpdate is not supported");const t=Wo(this._store,e,this._treeState);if("hasValue"===t.state)return t.contents;throw"hasError"===t.state?t.contents:a(`Expected Recoil atom ${e.key} to have a value, but it is in a loading state.`)})),u(this,"set",((e,t)=>{if(!Go(e))throw a("Setting selectors within atomicUpdate is not supported");if("function"===typeof t){const n=this.get(e);this._changes.set(e.key,t(n))}else this._changes.set(e.key,t)})),u(this,"reset",(e=>{this.set(e,zo)})),this._store=e,this._treeState=t,this._changes=new Map}newTreeState_INTERNAL(){if(0===this._changes.size)return this._treeState;const e=jo(this._treeState);for(const[t,n]of this._changes)qo(e,t,Po(n));return $o(this._store,e),e}}var Ko=function(e){return t=>{e.replaceState((n=>{const o=new Ho(e,n);return t(o),o.newTreeState_INTERNAL()}))}},Zo=Ko,Jo=Object.freeze({__proto__:null,atomicUpdater:Zo});var Xo=function(e,t){if(!e)throw new Error(t)};const{atomicUpdater:Qo}=Jo,{batchUpdates:Yo}=Rt,{DEFAULT_VALUE:er}=te,{useStoreRef:tr}=En,{setRecoilValue:nr}=nt,{Snapshot:or,cloneSnapshot:rr}=Zt,{useGotoRecoilSnapshot:ar}=Mo,{useCallback:sr}=o;class ir{}const ur=new ir;var cr=function(e,t){const n=tr(),o=ar();return sr(((...t)=>{function r(e,t){nr(n.current,e,t)}function s(e){nr(n.current,e,er)}const i=rr(n.current),u=Qo(n.current);let c=ur;return Yo((()=>{const n="useRecoilCallback expects a function that returns a function: it accepts a function of the type (RecoilInterface) => T = R and returns a callback function T => R, where RecoilInterface is an object {snapshot, set, ...} and T and R are the argument and return types of the callback you want to create.  Please see the docs at recoiljs.org for details.";if("function"!==typeof e)throw a(n);const l=e({set:r,reset:s,snapshot:i,gotoSnapshot:o,transact_UNSTABLE:u});if("function"!==typeof l)throw a(n);c=l(...t)})),c instanceof ir&&Xo(!1),c}),null!=t?[...t,n]:void 0)};const{getNode:lr}=te,{useStoreRef:dr}=En,{useCallback:fr}=o;var hr=function(e){const t=dr();return fr((()=>{var n;const o=t.current,{currentTree:r}=o.getState(),a=lr(e.key);null===(n=a.clearCache)||void 0===n||n.call(a,o,r)}),[e,t])};const{atomicUpdater:pr}=Jo,{useStoreRef:vr}=En,{useMemo:yr}=o;var mr=function(e,t){const n=vr();return yr((()=>(...t)=>{pr(n.current)((n=>{e(n)(...t)}))}),null!=t?[...t,n]:void 0)};const{isReactNative:_r,isSSR:gr}=yt;function Sr(e,t,n){if("string"===typeof e&&!e.includes('"')&&!e.includes("\\"))return`"${e}"`;switch(typeof e){case"undefined":return"";case"boolean":return e?"true":"false";case"number":case"symbol":return String(e);case"string":return JSON.stringify(e);case"function":if(!0!==(null===t||void 0===t?void 0:t.allowFunctions))throw a("Attempt to serialize function in a Recoil cache key");return`__FUNCTION(${e.name})__`}if(null===e)return"null";var o;if("object"!==typeof e)return null!==(o=JSON.stringify(e))&&void 0!==o?o:"";if(s(e))return"__PROMISE__";if(Array.isArray(e))return`[${e.map(((e,n)=>Sr(e,t,n.toString())))}]`;if("function"===typeof e.toJSON)return Sr(e.toJSON(n),t,n);if(e instanceof Map){const o={};for(const[n,r]of e)o["string"===typeof n?n:Sr(n,t)]=r;return Sr(o,t,n)}return e instanceof Set?Sr(Array.from(e).sort(((e,n)=>Sr(e,t).localeCompare(Sr(n,t)))),t,n):void 0!==Symbol&&null!=e[Symbol.iterator]&&"function"===typeof e[Symbol.iterator]?Sr(Array.from(e),t,n):`{${Object.keys(e).filter((t=>void 0!==e[t])).sort().map((n=>`${Sr(n,t)}:${Sr(e[n],t,n)}`)).join(",")}}`}var br=function(e,t={allowFunctions:!1}){return Sr(e,t)};const wr=(e,t,n)=>{var o;if(null==e)return;if(null===n||void 0===n||null===(o=n.onNodeVisit)||void 0===o||o.call(n,e),"leaf"===e.type)return e;const r=t(e.nodeKey);return wr(e.branches.get(r),t,n)},Tr=(e,t,n,o,r,a,s)=>{var i;let u;if(null==e)if(0===t.length)u={type:"leaf",value:o,parent:n,branchKey:r};else{const[e,...i]=t,[c,l]=e;u={type:"branch",nodeKey:c,parent:n,branches:new Map,branchKey:r},u.branches.set(l,Tr(null,i,u,o,l,a,s))}else if(u=e,t.length){const[n,...r]=t,[i,c]=n;if("branch"!==e.type||e.nodeKey!==i)return I("Existing cache must have a branch midway through the route with matching node key. Resetting cache."),s(),u;e.branches.set(c,Tr(e.branches.get(c),r,e,o,c,a,s))}return null===a||void 0===a||null===(i=a.onNodeVisit)||void 0===i||i.call(a,u),u},Rr=(e,t,n)=>n?(n.branches.delete(t.branchKey),Ar(e,n,n.parent)):e===t,Ar=(e,t,n)=>n?(0===t.branches.size&&n.branches.delete(t.branchKey),Ar(e,n,n.parent)):e===t,Er=e=>"leaf"===e.type?1:Array.from(e.branches.values()).reduce(((e,t)=>e+Er(t)),0);var Nr=class{constructor(e){var t,n,o;u(this,"_numLeafs",void 0),u(this,"_root",void 0),u(this,"_onHit",void 0),u(this,"_onSet",void 0),u(this,"_mapNodeValue",void 0),this._numLeafs=0,this._root=null,this._onHit=null!==(t=null===e||void 0===e?void 0:e.onHit)&&void 0!==t?t:()=>{},this._onSet=null!==(n=null===e||void 0===e?void 0:e.onSet)&&void 0!==n?n:()=>{},this._mapNodeValue=null!==(o=null===e||void 0===e?void 0:e.mapNodeValue)&&void 0!==o?o:e=>e}size(){return this._numLeafs}root(){return this._root}get(e,t){var n;return null===(n=this.getLeafNode(e,t))||void 0===n?void 0:n.value}getLeafNode(e,t){return wr(this.root(),(t=>this._mapNodeValue(e(t))),{onNodeVisit:e=>{null===t||void 0===t||t.onNodeVisit(e),"leaf"===e.type&&this._onHit(e)}})}set(e,t,n){let o,r=null;const a=()=>{r=Tr(this.root(),e.map((([e,t])=>[e,this._mapNodeValue(t)])),null,t,null,{onNodeVisit:e=>{null===n||void 0===n||n.onNodeVisit(e),"leaf"===e.type&&(o=e)}},(()=>{this.clear(),a()}))};a(),this.root()||(this._root=r),this._numLeafs++,this._onSet(i(o))}delete(e){if(!this.root())return!1;const t=i(this.root());return!!Rr(t,e,e.parent)&&(e===t||"branch"===t.type&&!t.branches.size?(this._root=null,this._numLeafs=0,!0):(this._numLeafs-=Er(e),!0))}clear(){this._numLeafs=0,this._root=null}},kr=Object.freeze({__proto__:null,TreeCache:Nr});var Vr=class{constructor(e){var t;u(this,"_maxSize",void 0),u(this,"_size",void 0),u(this,"_head",void 0),u(this,"_tail",void 0),u(this,"_map",void 0),u(this,"_keyMapper",void 0),this._maxSize=e.maxSize,this._size=0,this._head=null,this._tail=null,this._map=new Map,this._keyMapper=null!==(t=e.mapKey)&&void 0!==t?t:e=>e}head(){return this._head}tail(){return this._tail}size(){return this._size}maxSize(){return this._maxSize}has(e){return this._map.has(this._keyMapper(e))}get(e){const t=this._keyMapper(e),n=this._map.get(t);if(n)return this.set(e,n.value),n.value}set(e,t){const n=this._keyMapper(e);this._map.get(n)&&this.delete(e);const o=this.head(),r={key:e,right:o,left:null,value:t};o?o.left=r:this._tail=r,this._map.set(n,r),this._head=r,this._size++,this._maybeDeleteLRU()}_maybeDeleteLRU(){this.size()>this.maxSize()&&this.deleteLru()}deleteLru(){const e=this.tail();e&&this.delete(e.key)}delete(e){const t=this._keyMapper(e);if(!this._size||!this._map.has(t))return;const n=i(this._map.get(t)),o=n.right,r=n.left;o&&(o.left=n.left),r&&(r.right=n.right),n===this.head()&&(this._head=o),n===this.tail()&&(this._tail=r),this._map.delete(t),this._size--}clear(){this._size=0,this._head=null,this._tail=null,this._map=new Map}},Lr=Object.freeze({__proto__:null,LRUCache:Vr});const{LRUCache:Mr}=Lr,{TreeCache:Cr}=kr;var Ur=function(e,t=(e=>e)){const n=new Mr({maxSize:e}),o=new Cr({mapNodeValue:t,onHit:e=>{n.set(e,!0)},onSet:t=>{const r=n.tail();n.set(t,!0),r&&o.size()>e&&o.delete(r.key)}});return o};const{TreeCache:Br}=kr,Dr={equality:"reference",eviction:"keep-all",maxSize:1/0};var xr=function({equality:e=Dr.equality,eviction:t=Dr.eviction,maxSize:n=Dr.maxSize}=Dr){const o=function(e){switch(e){case"reference":return e=>e;case"value":return e=>br(e)}throw a(`Unrecognized equality policy ${e}`)}(e),r=function(e,t,n){switch(e){case"keep-all":return new Br({mapNodeValue:n});case"lru":return Ur(i(t),n);case"most-recent":return Ur(1,n)}throw a(`Unrecognized eviction policy ${e}`)}(t,n,o);return r};var Ir={startPerfBlock:function(e){return()=>null}};const{loadableWithError:Or,loadableWithPromise:Pr,loadableWithValue:zr}=N,{getNodeLoadable:Fr,peekNodeLoadable:jr,setNodeValue:Wr}=xe,{saveDependencyMapToStore:$r}=pe,{DEFAULT_VALUE:qr,RecoilValueNotReady:Gr,getConfigDeletionHandler:Hr,getNode:Kr,registerNode:Zr}=te,{isRecoilValue:Jr}=G,{AbstractRecoilValue:Xr}=G,{markRecoilValueModified:Qr,setRecoilValueLoadable:Yr}=nt,{retainedByOptionWithDefault:ea}=pt,{cloneSnapshot:ta}=Zt,{startPerfBlock:na}=Ir;class oa{}const ra=new oa,aa=[],sa=new Map,ia=(()=>{let e=0;return()=>e++})();var ua=function(e){let t=null;const{key:n,get:o,cachePolicy_UNSTABLE:r}=e,u=null!=e.set?e.set:void 0,c=new Set,l=xr(null!==r&&void 0!==r?r:{equality:"reference",eviction:"keep-all"}),d=ea(e.retainedBy_UNSTABLE),f=new Map;let h=0;function p(){return!D("recoil_memory_managament_2020")||h>0}function v(e){return f.has(e)||f.set(e,{depValuesDiscoveredSoFarDuringAsyncWork:null,latestLoadable:null,latestExecutionId:null,stateVersion:null}),i(f.get(e))}function y(e){return h++,e.getState().knownSelectors.add(n),()=>{h--,e.getState().knownSelectors.delete(n),f.delete(e)}}function m(){return void 0!==Hr(n)&&!p()}function _(e,t,n){if("loading"===t.state){let t=sa.get(n);null==t&&sa.set(n,t=new Set),t.add(e)}}function g(e,t,n){const o=e.getState().knownSelectors.has(n);if(o&&t.atomValues.has(n))return i(t.atomValues.get(n));const r=Fr(e,t,n);return"loading"!==r.state&&o&&t.atomValues.set(n,r),r}function S(e,t,n,o,r,a){return t.then((o=>{if(!p())throw M(e,r),ra;null!=a.loadingDepKey&&a.loadingDepPromise===t?n.atomValues.set(a.loadingDepKey,zr(o)):e.getState().knownSelectors.forEach((e=>{n.atomValues.delete(e)}));const s=R(e,n);if(s&&"hasValue"===s.state)return V(s,e),s.contents;if(!C(e,r)){var i;const e=N(n);if("loading"===(null===e||void 0===e||null===(i=e.latestLoadable)||void 0===i?void 0:i.state))return e.latestLoadable.contents}const[u,c]=T(e,n,r);if(C(e,r)&&L(c,e,r),"loading"!==u.state&&(B(n,A(c),u),w(e,n,new Set(c.keys()),r),b(e,u,r)),"hasError"===u.state)throw u.contents;return u.contents})).catch((t=>{if(t instanceof oa)throw I("Selector was released while it had dependencies"),ra;if(!p())throw M(e,r),ra;const a=Or(t);throw U(t),B(n,A(o),Or(t)),w(e,n,new Set(o.keys()),r),b(e,a,r),t}))}function b(e,t,o){C(e,o)&&(V(t,e),function(e,t){const o=sa.get(t);if(void 0!==o){for(const t of o)Yr(t,new Xr(n),e);sa.delete(t)}}(t,o))}function w(e,t,o,r){var a,s,i,u,c,l,d;(C(e,r)||t.version===(null===(a=e.getState())||void 0===a||null===(s=a.currentTree)||void 0===s?void 0:s.version)||t.version===(null===(i=e.getState())||void 0===i||null===(u=i.nextTree)||void 0===u?void 0:u.version))&&$r(new Map([[n,o]]),e,null!==(c=null===(l=e.getState())||void 0===l||null===(d=l.nextTree)||void 0===d?void 0:d.version)&&void 0!==c?c:e.getState().currentTree.version)}function T(e,t,r){const i=na(n);let u,c,l=!1;const d={loadingDepKey:null,loadingDepPromise:null},f=new Map,h=new Set;function v(n){const{key:o}=n;!function(e,t,n,o,r){n.add(o),w(e,t,n,r)}(e,t,h,o,r);const s=g(e,t,o);switch(f.set(o,s),s.state){case"hasValue":return s.contents;case"hasError":throw s.contents;case"loading":throw d.loadingDepKey=o,d.loadingDepPromise=s.contents,s.contents}throw a("Invalid Loadable state")}w(e,t,h,r);let y=!1;const m=t=>(...n)=>{if(!y)throw a("getCallback() should only be called asynchronously after the selector is evalutated.  It can be used for selectors to return objects with callbacks that can obtain the current Recoil state without a subscription.");const o=ta(e),r=t({snapshot:o});if("function"!==typeof r)throw a("getCallback() expects a function that returns a function.");return r(...n)};try{u=o({get:v,getCallback:m}),u=Jr(u)?v(u):u,y=!0,s(u)?u=function(e,t,n,o,r,a){return t.then((t=>{if(!p())throw M(e,r),ra;const a=zr(t);return U(t),B(n,A(o),a),w(e,n,new Set(o.keys()),r),b(e,a,r),t})).catch((t=>{if(!p())throw M(e,r),ra;if(C(e,r)&&L(o,e,r),s(t))return S(e,t,n,o,r,a);const i=Or(t);throw U(t),B(n,A(o),i),w(e,n,new Set(o.keys()),r),b(e,i,r),t}))}(e,u,t,f,r,d).finally(i):i()}catch(_){u=_,s(u)?u=S(e,u,t,f,r,d).finally(i):(l=!0,i())}return c=l?Or(u):s(u)?Pr(u):zr(u),"loading"!==c.state&&U(c.contents),[c,f]}function R(e,t){const o=new Set,r=v(e);let s;try{s=l.get((n=>{"string"!==typeof n&&Xo(!1);return g(e,t,n).contents}),{onNodeVisit:e=>{"branch"===e.type&&e.nodeKey!==n&&"string"===typeof e.nodeKey&&(o.add(e.nodeKey),c.add(e.nodeKey))}})}catch(i){throw a(`Problem with cache lookup for selector "${n}": ${i.message}`)}return s&&w(e,t,o,r.latestExecutionId),s}function A(e){return Array.from(e.entries()).map((([e,t])=>[e,t.contents]))}function E(e,t){const n=ia(),[o,r]=T(e,t,n);return V(o,e,r,n,t),function(e,t,n){"loading"!==n.state&&B(e,t,n)}(t,A(r),o),_(e,o,n),o}function N(e){var t;const[,n]=null!==(t=Array.from(f.entries()).find((([t,n])=>null!=n.latestLoadable&&null!=n.latestExecutionId&&!function(e,t){var n,o;const r=v(e),a=null!==(n=r.depValuesDiscoveredSoFarDuringAsyncWork)&&void 0!==n?n:new Map,s=Array((null!==(o=k.get(t.version))&&void 0!==o?o:new Map).entries()),i=k.has(t.version)&&s.length===a.size&&s.every((([e,t])=>a.get(e)===t));if(null==a||t.version===r.stateVersion||i)return!1;return k.set(t.version,new Map(a)),Array.from(a).some((([n,o])=>g(e,t,n).contents!==o.contents))}(t,e))))&&void 0!==t?t:[];return n}const k=new Map;function V(e,t,n,o,r){const a=v(t);"loading"===e.state?(a.depValuesDiscoveredSoFarDuringAsyncWork=n,a.latestExecutionId=o,a.latestLoadable=e,a.stateVersion=null===r||void 0===r?void 0:r.version):(a.depValuesDiscoveredSoFarDuringAsyncWork=null,a.latestExecutionId=null,a.latestLoadable=null,a.stateVersion=null)}function L(e,t,n){const o=v(t);C(t,n)&&(o.depValuesDiscoveredSoFarDuringAsyncWork=e)}function M(e,t){C(e,t)&&f.delete(e)}function C(e,t){return t===v(e).latestExecutionId}function U(e){0}function B(e,t,o){e.atomValues.set(n,o);try{l.set(t,o)}catch(r){throw a(`Problem with setting cache for selector "${n}": ${r.message}`)}}function x(e,t){return l.get((n=>{"string"!==typeof n&&Xo(!1);const o=jr(e,t,n);return null===o||void 0===o?void 0:o.contents}))}function O(e,t){return function(e){if(aa.includes(n)){const e=`Recoil selector has circular dependencies: ${aa.slice(aa.indexOf(n)).join(" \u2192 ")}`;return Or(a(e))}aa.push(n);try{return e()}finally{aa.pop()}}((()=>function(e,t){const n=R(e,t);if(null!=n)return V(n,e),n;const o=N(t);if(o){const t=o;return _(e,i(t.latestLoadable),i(t.latestExecutionId)),i(t.latestLoadable)}return E(e,t)}(e,t)))}function P(e){e.atomValues.delete(n)}function z(e,n){null==t&&Xo(!1);for(const t of c){var o;const r=Kr(t);null===(o=r.clearCache)||void 0===o||o.call(r,e,n)}P(n),l.clear(),Qr(e,t)}if(null!=u){return t=Zr({key:n,nodeType:"selector",peek:x,get:O,set:(e,t,n)=>{let o=!1;const r=new Map;function i({key:n}){if(o)throw a("Recoil: Async selector sets are not currently supported.");const r=g(e,t,n);if("hasValue"===r.state)return r.contents;throw"loading"===r.state?new Gr(n):r.contents}function c(n,s){if(o)throw a("Recoil: Async selector sets are not currently supported.");const u="function"===typeof s?s(i(n)):s;Wr(e,t,n.key,u).forEach(((e,t)=>r.set(t,e)))}const l=u({set:c,get:i,reset:function(e){c(e,qr)}},n);if(void 0!==l)throw s(l)?a("Recoil: Async selector sets are not currently supported."):a("Recoil: selector set should be a void function.");return o=!0,r},init:y,invalidate:P,clearCache:z,shouldDeleteConfigOnRelease:m,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:d})}return t=Zr({key:n,nodeType:"selector",peek:x,get:O,init:y,invalidate:P,clearCache:z,shouldDeleteConfigOnRelease:m,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:d})};const{loadableWithError:ca,loadableWithPromise:la,loadableWithValue:da}=N,{peekNodeInfo:fa}=xe,{DEFAULT_VALUE:ha,DefaultValue:pa,getConfigDeletionHandler:va,registerNode:ya,setConfigDeletionHandler:ma}=te,{isRecoilValue:_a}=G,{getRecoilValueAsLoadable:ga,markRecoilValueModified:Sa,setRecoilValue:ba,setRecoilValueLoadable:wa}=nt,{retainedByOptionWithDefault:Ta}=pt;function Ra(e){const{key:t,persistence_UNSTABLE:n}=e,o=Ta(e.retainedBy_UNSTABLE);let r,u=0,c=s(e.default)?la(e.default.then((e=>(c=da(e),e))).catch((e=>{throw c=ca(e),e}))):da(e.default);d(e.default);const l=new Map;function d(e){return e}const f=ya({key:t,nodeType:"atom",peek:function(e,n){var o,a;return null!==(o=null!==(a=n.atomValues.get(t))&&void 0!==a?a:r)&&void 0!==o?o:c},get:function(e,o){if(o.atomValues.has(t))return i(o.atomValues.get(t));if(o.nonvalidatedAtoms.has(t)){if(null!=r)return r;if(null==n)return V(`Tried to restore a persisted value for atom ${t} but it has no persistence settings.`),c;const e=o.nonvalidatedAtoms.get(t),a=n.validator(e,ha),s=a instanceof pa?c:da(a);return r=s,r}return c},set:function(e,n,o){if(n.atomValues.has(t)){const e=i(n.atomValues.get(t));if("hasValue"===e.state&&o===e.contents)return new Map}else if(!n.nonvalidatedAtoms.has(t)&&o instanceof pa)return new Map;return r=void 0,(new Map).set(t,da(o))},init:function(n,o,r){u++;const i=n.getState().knownAtoms.has(t);if(n.getState().knownAtoms.add(t),"loading"===c.state){const e=()=>{var e;(null!==(e=n.getState().nextTree)&&void 0!==e?e:n.getState().currentTree).atomValues.has(t)||Sa(n,f)};c.contents.then(e).catch(e)}let d=ha,h=null;if(null!=e.effects_UNSTABLE&&!i){let o=!0;function i(e){if(o&&e.key===t&&!(d instanceof pa)){const e=d;return e instanceof pa?c:s(e)?la(e.then((e=>e instanceof pa?c.toPromise():e))):da(e)}return ga(n,e)}function u(e){return i(e).toPromise()}function y(e){var r;const a=fa(n,null!==(r=n.getState().nextTree)&&void 0!==r?r:n.getState().currentTree,e.key);return!o||e.key!==t||d instanceof pa?a:{...a,isSet:!0,loadable:i(e)}}const m=e=>t=>{if(o){const n=d instanceof pa||s(d)?"hasValue"===c.state?c.contents:ha:d;d="function"===typeof t?t(n):t,s(d)&&(d=d.then((t=>(h={effect:e,value:t},t))))}else{if(s(t))throw a("Setting atoms to async values is not implemented.");"function"!==typeof t&&(h={effect:e,value:t}),ba(n,f,"function"===typeof t?n=>{const o=t(n);return h={effect:e,value:o},o}:t)}},_=e=>()=>m(e)(ha),g=e=>o=>{n.subscribeToTransactions((n=>{var r;let{currentTree:a,previousTree:s}=n.getState();s||(I("Transaction subscribers notified without a next tree being present -- this is a bug in Recoil"),s=a);const i=null!==(r=a.atomValues.get(t))&&void 0!==r?r:c;if("hasValue"===i.state){var u,l,d,f;const n=i.contents,r=null!==(u=s.atomValues.get(t))&&void 0!==u?u:c,p="hasValue"===r.state?r.contents:ha;(null===(l=h)||void 0===l?void 0:l.effect)!==e||(null===(d=h)||void 0===d?void 0:d.value)!==n?o(n,p,!a.atomValues.has(t)):(null===(f=h)||void 0===f?void 0:f.effect)===e&&(h=null)}}),t)};for(const t of null!==(p=e.effects_UNSTABLE)&&void 0!==p?p:[]){var p;const e=t({node:f,trigger:r,setSelf:m(t),resetSelf:_(t),onSet:g(t),getPromise:u,getLoadable:i,getInfo_UNSTABLE:y});var v;if(null!=e)l.set(n,[...null!==(v=l.get(n))&&void 0!==v?v:[],e])}o=!1}if(!(d instanceof pa)){var y;const e=d,r=s(e)?la(function(e,n){const o=n.then((n=>{var r,a;return(null===(a=(null!==(r=e.getState().nextTree)&&void 0!==r?r:e.getState().currentTree).atomValues.get(t))||void 0===a?void 0:a.contents)===o&&ba(e,f,n),n})).catch((n=>{var r,a;throw(null===(a=(null!==(r=e.getState().nextTree)&&void 0!==r?r:e.getState().currentTree).atomValues.get(t))||void 0===a?void 0:a.contents)===o&&wa(e,f,ca(n)),n}));return o}(n,e)):da(e);o.atomValues.set(t,r),null===(y=n.getState().nextTree)||void 0===y||y.atomValues.set(t,r)}return()=>{var e;u--,null===(e=l.get(n))||void 0===e||e.forEach((e=>e())),l.delete(n),n.getState().knownAtoms.delete(t)}},invalidate:function(){r=void 0},shouldDeleteConfigOnRelease:function(){return void 0!==va(t)&&u<=0},dangerouslyAllowMutability:e.dangerouslyAllowMutability,persistence_UNSTABLE:e.persistence_UNSTABLE?{type:e.persistence_UNSTABLE.type,backButton:e.persistence_UNSTABLE.backButton}:void 0,shouldRestoreFromSnapshots:!0,retainedBy:o});return f}function Aa(e){const{default:t,...n}=e;return _a(t)?function(e){const t=Aa({...e,default:ha,persistence_UNSTABLE:void 0===e.persistence_UNSTABLE?void 0:{...e.persistence_UNSTABLE,validator:t=>t instanceof pa?t:i(e.persistence_UNSTABLE).validator(t,ha)},effects_UNSTABLE:e.effects_UNSTABLE}),n=ua({key:`${e.key}__withFallback`,get:({get:n})=>{const o=n(t);return o instanceof pa?e.default:o},set:({set:e},n)=>e(t,n),dangerouslyAllowMutability:e.dangerouslyAllowMutability});return ma(n.key,va(e.key)),n}({...n,default:t}):Ra({...n,default:t})}var Ea=Aa;var Na=class{constructor(e){var t;u(this,"_map",void 0),u(this,"_keyMapper",void 0),this._map=new Map,this._keyMapper=null!==(t=null===e||void 0===e?void 0:e.mapKey)&&void 0!==t?t:e=>e}size(){return this._map.size}has(e){return this._map.has(this._keyMapper(e))}get(e){return this._map.get(this._keyMapper(e))}set(e,t){this._map.set(this._keyMapper(e),t)}delete(e){this._map.delete(this._keyMapper(e))}clear(){this._map.clear()}},ka=Object.freeze({__proto__:null,MapCache:Na});const{LRUCache:Va}=Lr,{MapCache:La}=ka,Ma={equality:"reference",eviction:"none",maxSize:1/0};var Ca=function({equality:e=Ma.equality,eviction:t=Ma.eviction,maxSize:n=Ma.maxSize}=Ma){const o=function(e){switch(e){case"reference":return e=>e;case"value":return e=>br(e)}throw a(`Unrecognized equality policy ${e}`)}(e),r=function(e,t,n){switch(e){case"keep-all":return new La({mapKey:n});case"lru":return new Va({mapKey:n,maxSize:i(t)});case"most-recent":return new Va({mapKey:n,maxSize:1})}throw a(`Unrecognized eviction policy ${e}`)}(t,n,o);return r};const{setConfigDeletionHandler:Ua}=te;var Ba=function(e){var t,n;const o=Ca({equality:null!==(t=null===(n=e.cachePolicyForParams_UNSTABLE)||void 0===n?void 0:n.equality)&&void 0!==t?t:"value",eviction:"keep-all"});return t=>{var n;const r=o.get(t);if(null!=r)return r;const{cachePolicyForParams_UNSTABLE:a,...s}=e,i=Ea({...s,key:`${e.key}__${null!==(n=br(t))&&void 0!==n?n:"void"}`,default:"function"===typeof e.default?e.default(t):e.default,retainedBy_UNSTABLE:"function"===typeof e.retainedBy_UNSTABLE?e.retainedBy_UNSTABLE(t):e.retainedBy_UNSTABLE,effects_UNSTABLE:"function"===typeof e.effects_UNSTABLE?e.effects_UNSTABLE(t):e.effects_UNSTABLE});return o.set(t,i),Ua(i.key,(()=>{o.delete(t)})),i}};const{setConfigDeletionHandler:Da}=te;let xa=0;var Ia=function(e){var t,n;const o=Ca({equality:null!==(t=null===(n=e.cachePolicyForParams_UNSTABLE)||void 0===n?void 0:n.equality)&&void 0!==t?t:"value",eviction:"keep-all"});return t=>{var n;const r=o.get(t);if(null!=r)return r;const a=`${e.key}__selectorFamily/${null!==(n=br(t,{allowFunctions:!0}))&&void 0!==n?n:"void"}/${xa++}`,s=n=>e.get(t)(n),i=e.cachePolicy_UNSTABLE,u="function"===typeof e.retainedBy_UNSTABLE?e.retainedBy_UNSTABLE(t):e.retainedBy_UNSTABLE;let c;if(null!=e.set){const n=e.set;c=ua({key:a,get:s,set:(e,o)=>n(t)(e,o),cachePolicy_UNSTABLE:i,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:u})}else c=ua({key:a,get:s,cachePolicy_UNSTABLE:i,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:u});return o.set(t,c),Da(c.key,(()=>{o.delete(t)})),c}};const Oa=Ia({key:"__constant",get:e=>()=>e,cachePolicyForParams_UNSTABLE:{equality:"reference"}});var Pa=function(e){return Oa(e)};const za=Ia({key:"__error",get:e=>()=>{throw a(e)},cachePolicyForParams_UNSTABLE:{equality:"reference"}});var Fa=function(e){return za(e)};var ja=function(e){return e};const{loadableWithError:Wa,loadableWithPromise:$a,loadableWithValue:qa}=N;function Ga(e,t){const n=Array(t.length).fill(void 0),o=Array(t.length).fill(void 0);for(const[a,s]of t.entries())try{n[a]=e(s)}catch(r){o[a]=r}return[n,o]}function Ha(e){return null!=e&&!s(e)}function Ka(e){return Array.isArray(e)?e:Object.getOwnPropertyNames(e).map((t=>e[t]))}function Za(e,t){return Array.isArray(e)?t:Object.getOwnPropertyNames(e).reduce(((e,n,o)=>({...e,[n]:t[o]})),{})}function Ja(e,t,n){return Za(e,n.map(((e,n)=>null==e?qa(t[n]):s(e)?$a(e):Wa(e))))}var Xa={waitForNone:Ia({key:"__waitForNone",get:e=>({get:t})=>{const n=Ka(e),[o,r]=Ga(t,n);return Ja(e,o,r)},dangerouslyAllowMutability:!0}),waitForAny:Ia({key:"__waitForAny",get:e=>({get:t})=>{const n=Ka(e),[o,r]=Ga(t,n);return r.some((e=>!s(e)))?Ja(e,o,r):new Promise((t=>{for(const[n,a]of r.entries())s(a)&&a.then((a=>{o[n]=a,r[n]=void 0,t(Ja(e,o,r))})).catch((a=>{r[n]=a,t(Ja(e,o,r))}))}))},dangerouslyAllowMutability:!0}),waitForAll:Ia({key:"__waitForAll",get:e=>({get:t})=>{const n=Ka(e),[o,r]=Ga(t,n);if(r.every((e=>null==e)))return Za(e,o);const a=r.find(Ha);if(null!=a)throw a;return Promise.all(r).then((t=>{return Za(e,(n=o,t.map(((e,t)=>void 0===e?n[t]:e))));var n}))},dangerouslyAllowMutability:!0}),waitForAllSettled:Ia({key:"__waitForAllSettled",get:e=>({get:t})=>{const n=Ka(e),[o,r]=Ga(t,n);return r.every((e=>!s(e)))?Ja(e,o,r):Promise.all(r.map(((e,t)=>s(e)?e.then((e=>{o[t]=e,r[t]=void 0})).catch((e=>{o[t]=void 0,r[t]=e})):null))).then((()=>Ja(e,o,r)))},dangerouslyAllowMutability:!0}),noWait:Ia({key:"__noWait",get:e=>({get:t})=>{try{return qa(t(e))}catch(n){return s(n)?$a(n):Wa(n)}},dangerouslyAllowMutability:!0})};const{RecoilLoadable:Qa}=N,{DefaultValue:Ya}=te,{RecoilRoot:es}=En,{isRecoilValue:ts}=G,{retentionZone:ns}=Ae,{freshSnapshot:os}=Zt,{useRecoilState:rs,useRecoilStateLoadable:as,useRecoilValue:ss,useRecoilValueLoadable:is,useResetRecoilState:us,useSetRecoilState:cs,useSetUnvalidatedAtomValues:ls}=co,{useGotoRecoilSnapshot:ds,useRecoilSnapshot:fs,useRecoilTransactionObserver:hs,useTransactionObservation_DEPRECATED:ps}=Mo,{noWait:vs,waitForAll:ys,waitForAllSettled:ms,waitForAny:_s,waitForNone:gs}=Xa;var Ss={DefaultValue:Ya,isRecoilValue:ts,RecoilLoadable:Qa,RecoilRoot:es,useRecoilBridgeAcrossReactRoots_UNSTABLE:Oo,atom:Ea,selector:ua,atomFamily:Ba,selectorFamily:Ia,constSelector:Pa,errorSelector:Fa,readOnlySelector:ja,noWait:vs,waitForNone:gs,waitForAny:_s,waitForAll:ys,waitForAllSettled:ms,useRecoilValue:ss,useRecoilValueLoadable:is,useRecoilState:rs,useRecoilStateLoadable:as,useSetRecoilState:cs,useResetRecoilState:us,useGetRecoilValueInfo_UNSTABLE:Bo,useRecoilRefresher_UNSTABLE:hr,useRecoilCallback:cr,useRecoilTransaction_UNSTABLE:mr,useGotoRecoilSnapshot:ds,useRecoilSnapshot:fs,useRecoilTransactionObserver_UNSTABLE:hs,useTransactionObservation_UNSTABLE:ps,useSetUnvalidatedAtomValues_UNSTABLE:ls,snapshot_UNSTABLE:os,useRetain:zn,retentionZone:ns},bs=Ss.RecoilRoot,ws=Ss.atom,Ts=Ss.useRecoilValue,Rs=Ss.useRecoilState}},function(e){var t=function(t){return e(e.s=t)};e.O(0,[774,179],(function(){return t(1118),t(880)}));var n=e.O();_N_E=n}]);